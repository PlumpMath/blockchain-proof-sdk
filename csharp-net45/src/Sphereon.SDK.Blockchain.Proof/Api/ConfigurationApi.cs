/* 
 * Blockchain Proof
 *
 * With the Blockchain Proof API it is easy to prove or disprove existence of data at a certain point in time. Behind the scenes it stores entries using the Factom (bitcoin), Multichain or Ethereum blockchain by means of our generic blockchain API.    The flow is generally as follows:  1. Make sure a configuration is present  2. Register content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing  3. Verify content by uploading a file, some content, or providing a Stream Location from the Storage API. When you upload content you have to tell the API whether the data has already been hashed or not. If not, or when uploading a file or stream location, the API will take care of the hashing. You will get back whether the content has been registered previously or not    Full API Documentation: https://docs.sphereon.com/api/blockchain-proof/0.9/html  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 0.9
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Sphereon.SDK.Blockchain.Proof.Client;
using Sphereon.SDK.Blockchain.Proof.Model;

namespace Sphereon.SDK.Blockchain.Proof.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConfigurationApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create a new configuration
        /// </summary>
        /// <remarks>
        /// Create a new configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse CreateConfiguration (CreateConfigurationRequest request);

        /// <summary>
        /// Create a new configuration
        /// </summary>
        /// <remarks>
        /// Create a new configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> CreateConfigurationWithHttpInfo (CreateConfigurationRequest request);
        /// <summary>
        /// Get configuration
        /// </summary>
        /// <remarks>
        /// Get the configuration for registration/verification
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>ConfigurationResponse</returns>
        ConfigurationResponse GetConfiguration (string configName);

        /// <summary>
        /// Get configuration
        /// </summary>
        /// <remarks>
        /// Get the configuration for registration/verification
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        ApiResponse<ConfigurationResponse> GetConfigurationWithHttpInfo (string configName);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Create a new configuration
        /// </summary>
        /// <remarks>
        /// Create a new configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> CreateConfigurationAsync (CreateConfigurationRequest request);

        /// <summary>
        /// Create a new configuration
        /// </summary>
        /// <remarks>
        /// Create a new configuration
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> CreateConfigurationAsyncWithHttpInfo (CreateConfigurationRequest request);
        /// <summary>
        /// Get configuration
        /// </summary>
        /// <remarks>
        /// Get the configuration for registration/verification
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>Task of ConfigurationResponse</returns>
        System.Threading.Tasks.Task<ConfigurationResponse> GetConfigurationAsync (string configName);

        /// <summary>
        /// Get configuration
        /// </summary>
        /// <remarks>
        /// Get the configuration for registration/verification
        /// </remarks>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> GetConfigurationAsyncWithHttpInfo (string configName);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ConfigurationApi : IConfigurationApi
    {
        private Sphereon.SDK.Blockchain.Proof.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ConfigurationApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Sphereon.SDK.Blockchain.Proof.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConfigurationApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ConfigurationApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Sphereon.SDK.Blockchain.Proof.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Sphereon.SDK.Blockchain.Proof.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create a new configuration Create a new configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse CreateConfiguration (CreateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = CreateConfigurationWithHttpInfo(request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a new configuration Create a new configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > CreateConfigurationWithHttpInfo (CreateConfigurationRequest request)
        {
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigurationApi->CreateConfiguration");

            var localVarPath = "/config";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Create a new configuration Create a new configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> CreateConfigurationAsync (CreateConfigurationRequest request)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await CreateConfigurationAsyncWithHttpInfo(request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a new configuration Create a new configuration
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">Create a new Proof of Existence configuration using the provided settings. The context points to a context of the Easy Blockchain API. When you have no own context, simply use &#39;multichain&#39; without the quotes as context. You will be using our multichain ledger then, which is recomended during development/testing</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> CreateConfigurationAsyncWithHttpInfo (CreateConfigurationRequest request)
        {
            // verify the required parameter 'request' is set
            if (request == null)
                throw new ApiException(400, "Missing required parameter 'request' when calling ConfigurationApi->CreateConfiguration");

            var localVarPath = "/config";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Get configuration Get the configuration for registration/verification
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>ConfigurationResponse</returns>
        public ConfigurationResponse GetConfiguration (string configName)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = GetConfigurationWithHttpInfo(configName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get configuration Get the configuration for registration/verification
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>ApiResponse of ConfigurationResponse</returns>
        public ApiResponse< ConfigurationResponse > GetConfigurationWithHttpInfo (string configName)
        {
            // verify the required parameter 'configName' is set
            if (configName == null)
                throw new ApiException(400, "Missing required parameter 'configName' when calling ConfigurationApi->GetConfiguration");

            var localVarPath = "/config/{configName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (configName != null) localVarPathParams.Add("configName", Configuration.ApiClient.ParameterToString(configName)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

        /// <summary>
        /// Get configuration Get the configuration for registration/verification
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>Task of ConfigurationResponse</returns>
        public async System.Threading.Tasks.Task<ConfigurationResponse> GetConfigurationAsync (string configName)
        {
             ApiResponse<ConfigurationResponse> localVarResponse = await GetConfigurationAsyncWithHttpInfo(configName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get configuration Get the configuration for registration/verification
        /// </summary>
        /// <exception cref="Sphereon.SDK.Blockchain.Proof.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="configName">The configuration name this operation</param>
        /// <returns>Task of ApiResponse (ConfigurationResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ConfigurationResponse>> GetConfigurationAsyncWithHttpInfo (string configName)
        {
            // verify the required parameter 'configName' is set
            if (configName == null)
                throw new ApiException(400, "Missing required parameter 'configName' when calling ConfigurationApi->GetConfiguration");

            var localVarPath = "/config/{configName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json;charset=UTF-8"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (configName != null) localVarPathParams.Add("configName", Configuration.ApiClient.ParameterToString(configName)); // path parameter

            // authentication (oauth2schema) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetConfiguration", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ConfigurationResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ConfigurationResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ConfigurationResponse)));
        }

    }
}

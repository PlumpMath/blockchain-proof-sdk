/* 
 * Blockchain Proof
 *
 * <b>With the Blockchain Proof API it is easy to prove existence of (binary) data at a certain point in time. Behind the scenes it stores entries using the Factom (bitcoin) blockchain by means of our generic blockchain API.</b>    The flow is generally as follows:  1. Make sure a Proof chain has been created using the /chain POST endpoint beforehand. Normally you only need one or a handful of chains, during the entiry lifetime of your proof solution. This is a relative expensive operation in terms of money.  2. Store proof entries on the proof chain from step 1. The entries will contain the content and metadata you want to store forever on the specified chain.  3. Retrieve an existing entry from the chain to verify or retrieve data      <b>Interactive testing: </b>A web based test console is available in the <a href=\"https://store.sphereon.com\">Sphereon API Store</a>
 *
 * OpenAPI spec version: 0.1.0
 * Contact: dev@sphereon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = Sphereon.SDK.Blockchain.Proof.Client.SwaggerDateConverter;

namespace Sphereon.SDK.Blockchain.Proof.Model
{
    /// <summary>
    /// Create chain for Proof of Existence request
    /// </summary>
    [DataContract]
    public partial class CreateChainRequest :  IEquatable<CreateChainRequest>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateChainRequest" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CreateChainRequest() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateChainRequest" /> class.
        /// </summary>
        /// <param name="Metadata">Metadata for this chain..</param>
        /// <param name="SettingsChainId">Supply an existing settings chain. When not supplied a new settings chain will be created automatically..</param>
        /// <param name="Name">Unique name for this chain. (required).</param>
        /// <param name="PreviousChainId">When this chain is a continuation of another chain you need to supply the previous chainId here..</param>
        /// <param name="DefaultSettings">DefaultSettings (required).</param>
        public CreateChainRequest(byte[] Metadata = default(byte[]), string SettingsChainId = default(string), string Name = default(string), string PreviousChainId = default(string), Settings DefaultSettings = default(Settings))
        {
            // to ensure "Name" is required (not null)
            if (Name == null)
            {
                throw new InvalidDataException("Name is a required property for CreateChainRequest and cannot be null");
            }
            else
            {
                this.Name = Name;
            }
            // to ensure "DefaultSettings" is required (not null)
            if (DefaultSettings == null)
            {
                throw new InvalidDataException("DefaultSettings is a required property for CreateChainRequest and cannot be null");
            }
            else
            {
                this.DefaultSettings = DefaultSettings;
            }
            this.Metadata = Metadata;
            this.SettingsChainId = SettingsChainId;
            this.PreviousChainId = PreviousChainId;
        }
        
        /// <summary>
        /// Metadata for this chain.
        /// </summary>
        /// <value>Metadata for this chain.</value>
        [DataMember(Name="metadata", EmitDefaultValue=false)]
        public byte[] Metadata { get; set; }

        /// <summary>
        /// Supply an existing settings chain. When not supplied a new settings chain will be created automatically.
        /// </summary>
        /// <value>Supply an existing settings chain. When not supplied a new settings chain will be created automatically.</value>
        [DataMember(Name="settingsChainId", EmitDefaultValue=false)]
        public string SettingsChainId { get; set; }

        /// <summary>
        /// Unique name for this chain.
        /// </summary>
        /// <value>Unique name for this chain.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// When this chain is a continuation of another chain you need to supply the previous chainId here.
        /// </summary>
        /// <value>When this chain is a continuation of another chain you need to supply the previous chainId here.</value>
        [DataMember(Name="previousChainId", EmitDefaultValue=false)]
        public string PreviousChainId { get; set; }

        /// <summary>
        /// Gets or Sets DefaultSettings
        /// </summary>
        [DataMember(Name="defaultSettings", EmitDefaultValue=false)]
        public Settings DefaultSettings { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CreateChainRequest {\n");
            sb.Append("  Metadata: ").Append(Metadata).Append("\n");
            sb.Append("  SettingsChainId: ").Append(SettingsChainId).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  PreviousChainId: ").Append(PreviousChainId).Append("\n");
            sb.Append("  DefaultSettings: ").Append(DefaultSettings).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            return this.Equals(obj as CreateChainRequest);
        }

        /// <summary>
        /// Returns true if CreateChainRequest instances are equal
        /// </summary>
        /// <param name="other">Instance of CreateChainRequest to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CreateChainRequest other)
        {
            // credit: http://stackoverflow.com/a/10454552/677735
            if (other == null)
                return false;

            return 
                (
                    this.Metadata == other.Metadata ||
                    this.Metadata != null &&
                    this.Metadata.Equals(other.Metadata)
                ) && 
                (
                    this.SettingsChainId == other.SettingsChainId ||
                    this.SettingsChainId != null &&
                    this.SettingsChainId.Equals(other.SettingsChainId)
                ) && 
                (
                    this.Name == other.Name ||
                    this.Name != null &&
                    this.Name.Equals(other.Name)
                ) && 
                (
                    this.PreviousChainId == other.PreviousChainId ||
                    this.PreviousChainId != null &&
                    this.PreviousChainId.Equals(other.PreviousChainId)
                ) && 
                (
                    this.DefaultSettings == other.DefaultSettings ||
                    this.DefaultSettings != null &&
                    this.DefaultSettings.Equals(other.DefaultSettings)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            // credit: http://stackoverflow.com/a/263416/677735
            unchecked // Overflow is fine, just wrap
            {
                int hash = 41;
                // Suitable nullity checks etc, of course :)
                if (this.Metadata != null)
                    hash = hash * 59 + this.Metadata.GetHashCode();
                if (this.SettingsChainId != null)
                    hash = hash * 59 + this.SettingsChainId.GetHashCode();
                if (this.Name != null)
                    hash = hash * 59 + this.Name.GetHashCode();
                if (this.PreviousChainId != null)
                    hash = hash * 59 + this.PreviousChainId.GetHashCode();
                if (this.DefaultSettings != null)
                    hash = hash * 59 + this.DefaultSettings.GetHashCode();
                return hash;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
